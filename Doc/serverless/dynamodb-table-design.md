# DynamoDBテーブル・インデックス設計

## 1. 設計原則

DynamoDBの設計では、以下の原則に従います：

1. アクセスパターンを最優先した設計
2. GSI（Global Secondary Index）とLSI（Local Secondary Index）の適切な利用
3. 項目サイズの制限（400KB）を考慮したデータ分割
4. 読み取り/書き込みのスループット最適化
5. データの一貫性と整合性の確保
6. ホットパーティションの回避

## 2. テーブル設計概要

アプリケーション全体で以下の主要テーブルを設計します：

1. Users - ユーザー情報管理
2. Bookings - 予約情報管理
3. Calendar - カレンダー表示用データ
4. Options - オプションサービス情報
5. Notifications - 通知管理
6. TermsOfService - 利用規約管理 
7. UserAgreements - 利用規約同意履歴

## 3. テーブル詳細設計

### 3.1 Users テーブル

**テーブル名**: `studio-booking-users`

**主要目的**: ユーザープロフィール情報とアカウント管理

**プライマリキー**:
- パーティションキー (PK): `USER#<userId>` (String)

**GSI**:
- GSI1: 
  - パーティションキー: `email` (String)
  - 目的: メールアドレスによるユーザー検索（ログイン時等）

**項目構造**:
```json
{
  "PK": "USER#123e4567-e89b-12d3-a456-426614174000",
  "email": "user@example.com",
  "hashedPassword": "bcrypt-hashed-password-string",
  "fullName": "山田太郎",
  "companyName": "株式会社スタジオ",
  "address": "東京都渋谷区...",
  "phone": "090-1234-5678",
  "isAdmin": false,
  "totalUsageMinutes": 480,
  "bookingCount": 5,
  "createdAt": "2025-06-01T10:00:00Z",
  "updatedAt": "2025-06-10T15:30:00Z"
}
```

**主要アクセスパターン**:
1. ユーザーIDによるユーザー取得 - `GetItem` on PK
2. メールアドレスによるユーザー検索 - `Query` on GSI1

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- 個人情報を含むため、テーブルレベルでの暗号化を有効化
- トークン関連情報は別途管理（Cognito または専用テーブル）
- レコードは頻繁に更新されないため、読み取り最適化

---

### 3.2 Bookings テーブル

**テーブル名**: `studio-booking-bookings`

**主要目的**: 予約管理と検索

**プライマリキー**:
- パーティションキー (PK): `BOOKING#<bookingId>` (String)
- ソートキー (SK): `USER#<userId>` (String)

**GSI**:
- GSI1: ユーザー別予約一覧
  - パーティションキー: `USER#<userId>` (String)
  - ソートキー: `BOOKING#<createdAt>` (String)
  - 投影: ALL
  - 目的: 特定ユーザーの予約一覧を作成日順で取得
  
- GSI2: ステータス別予約一覧
  - パーティションキー: `STATUS#<status>` (String)
  - ソートキー: `<startTime>` (String, ISO形式)
  - 投影: ALL
  - 目的: 特定ステータス（承認待ちなど）の予約を開始時間順で取得

- GSI3: 日付別予約一覧
  - パーティションキー: `DATE#<YYYY-MM-DD>` (String)
  - ソートキー: `TIME#<startTime>` (String)
  - 投影: ALL
  - 目的: 特定日付の予約を時間順で取得

**項目構造**:
```json
{
  "PK": "BOOKING#b123e456",
  "SK": "USER#123e4567-e89b-12d3-a456-426614174000",
  "USER#123e4567-e89b-12d3-a456-426614174000": "BOOKING#2025-06-01T10:00:00Z",
  "STATUS#pending": "2025-06-15T13:00:00Z",
  "DATE#2025-06-15": "TIME#13:00:00Z",
  "bookingId": "b123e456",
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "userEmail": "user@example.com",
  "userName": "山田太郎",
  "companyName": "株式会社スタジオ",
  "photographerName": "佐藤カメラマン",
  "plan": "A",
  "planDetails": "10人以下でのご利用 ¥5,000/1h（税込￥5,500/1h）",
  "insurance": {
    "selected": true,
    "name": "機材保険の付帯",
    "price": 1000,
    "taxIncludedPrice": 1100
  },
  "startTime": "2025-06-15T13:00:00Z",
  "endTime": "2025-06-15T17:00:00Z",
  "status": "pending",
  "bookingType": "temporary",
  "purpose": "商品撮影",
  "shootingDetails": "商品カタログ用のアパレル撮影。モデル2名とスタイリスト1名が参加予定。",
  "protection": "あり",
  "peopleCount": 3,
  "confirmationDeadline": "2025-06-08T18:00:00Z",
  "automaticCancellation": true,
  "cancellationFeePercent": 0,
  "options": [
    {
      "id": "LED",
      "name": "LEDライト",
      "quantity": 2, 
      "price": 1000,
      "taxIncludedPrice": 1100,
      "category": "equipment"
    },
    {
      "id": "backPaper",
      "name": "背景紙",
      "quantity": 3,
      "price": 2300,
      "taxIncludedPrice": 2530,
      "category": "equipment"
    },
    {
      "id": "workshop",
      "name": "6人以上のワークショップでご利用",
      "quantity": 1,
      "price": 2000,
      "taxIncludedPrice": 2200,
      "category": "service"
    },
    {
      "id": "glitter",
      "name": "ラメやグリッターを多用した衣装（小道具）のお持ち込み",
      "quantity": 1,
      "price": 2000,
      "taxIncludedPrice": 2200,
      "category": "service"
    }
  ],
  "approvedBy": null,
  "approvedAt": null,
  "createdAt": "2025-06-01T10:00:00Z",
  "updatedAt": "2025-06-01T10:00:00Z"
}
```

**主要アクセスパターン**:
1. 予約ID＋ユーザーIDによる予約詳細取得 - `GetItem` on PK + SK
2. ユーザー別予約履歴取得 - `Query` on GSI1
3. ステータス別予約一覧取得 - `Query` on GSI2
4. 日付別予約一覧取得 - `Query` on GSI3
5. 仮予約期限超過レコード取得 - `Scan` + フィルター式（またはGSI）

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- ユーザー情報（email, name）は非正規化して格納
- オプション情報も非正規化して格納
- テーブルレベルでの暗号化を有効化
- DynamoDB Streamsを有効化し、イベント駆動処理を実装

---

### 3.3 Calendar テーブル

**テーブル名**: `studio-booking-calendar`

**主要目的**: カレンダー表示の最適化、空き状況の高速取得

**プライマリキー**:
- パーティションキー (PK): `DATE#<YYYY-MM-DD>` (String)
- ソートキー (SK): `TIME#<startTime>#<endTime>` (String)

**項目構造**:
```json
{
  "PK": "DATE#2025-06-15",
  "SK": "TIME#13:00:00#17:00:00",
  "bookingId": "b123e456",
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "status": "pending",
  "bookingType": "temporary",
  "startTime": "2025-06-15T13:00:00Z",
  "endTime": "2025-06-15T17:00:00Z"
}
```

**主要アクセスパターン**:
1. 日付による予約時間枠取得 - `Query` on PK
2. 日付範囲による予約状況取得 - 複数 `Query`（バッチ処理）

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- このテーブルはBookingsテーブルと冗長性を持たせることでカレンダー表示の読み取り負荷を最適化
- 予約変更時はトランザクションを使用して両テーブルの整合性を確保

---

### 3.4 Options テーブル

**テーブル名**: `studio-booking-options`

**主要目的**: オプションサービス情報管理

**プライマリキー**:
- パーティションキー (PK): `OPTION#<optionId>` (String)

**項目構造**:
```json
{
  "PK": "OPTION#opt1",
  "name": "LEDライト",
  "description": "1回の利用につき1,000円の追加料金が発生します。",
  "unitPrice": 1000,
  "unit": "台",
  "isActive": true,
  "createdAt": "2025-01-01T10:00:00Z",
  "updatedAt": "2025-01-01T10:00:00Z"
}
```

**主要アクセスパターン**:
1. オプションIDによる詳細取得 - `GetItem` on PK
2. 全オプションリスト取得 - `Scan` (テーブルサイズが小さいため許容)

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- データ量が少なく頻繁に更新されないため、シンプルな設計
- 予約データではオプション情報を非正規化して格納

---

### 3.5 Notifications テーブル

**テーブル名**: `studio-booking-notifications`

**主要目的**: ユーザー通知管理

**プライマリキー**:
- パーティションキー (PK): `USER#<userId>` (String)
- ソートキー (SK): `NOTIFICATION#<timestamp>` (String)

**GSI**:
- GSI1: タイプ別通知一覧
  - パーティションキー: `TYPE#<notificationType>` (String)
  - ソートキー: `<timestamp>` (String)
  - 投影: ALL
  - 目的: 通知タイプごとの一覧取得（システム分析等）

**項目構造**:
```json
{
  "PK": "USER#123e4567-e89b-12d3-a456-426614174000",
  "SK": "NOTIFICATION#2025-06-01T10:30:00Z",
  "TYPE#booking": "2025-06-01T10:30:00Z",
  "title": "予約申請を承認しました",
  "content": "6月15日13:00～17:00の予約申請が承認されました。",
  "type": "booking",
  "isRead": false,
  "relatedEntityId": "b123e456",
  "createdAt": "2025-06-01T10:30:00Z",
  "readAt": null
}
```

**主要アクセスパターン**:
1. ユーザー別通知一覧取得 - `Query` on PK
2. ユーザー別未読通知取得 - `Query` on PK + フィルター式
3. 通知タイプ別一覧取得 - `Query` on GSI1

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- 通知は生成量が多くなる可能性があるため、古い通知の削除や移行戦略が必要
- TTL (Time To Live) の使用を検討

---

### 3.6 TermsOfService テーブル

**テーブル名**: `studio-booking-terms-of-service`

**主要目的**: 利用規約バージョン管理

**プライマリキー**:
- パーティションキー (PK): `TERMS#<version>` (String)

**GSI**:
- GSI1: 日付による取得
  - パーティションキー: `STATUS` (String, "active" or "inactive")
  - ソートキー: `effectiveDate` (String, ISO形式)
  - 投影: ALL
  - 目的: 有効/無効な利用規約を日付順に取得

**項目構造**:
```json
{
  "PK": "TERMS#1.0",
  "STATUS": "active",
  "version": "1.0",
  "title": "スタジオ利用規約 2025年版",
  "content": "利用規約の内容...",
  "effectiveDate": "2025-01-01T00:00:00Z",
  "createdAt": "2024-12-01T10:00:00Z",
  "updatedAt": "2024-12-01T10:00:00Z"
}
```

**主要アクセスパターン**:
1. バージョンによる規約取得 - `GetItem` on PK
2. 最新の有効な規約取得 - `Query` on GSI1 (STATUS="active") + Limit 1

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- データ量が非常に少ないため、シンプルな設計
- 新しい規約バージョンを追加する際には、Lambda関数で全ユーザーへの通知を生成

---

### 3.7 UserAgreements テーブル

**テーブル名**: `studio-booking-user-agreements`

**主要目的**: ユーザーの利用規約同意履歴管理

**プライマリキー**:
- パーティションキー (PK): `USER#<userId>` (String)
- ソートキー (SK): `TERMS#<version>` (String)

**項目構造**:
```json
{
  "PK": "USER#123e4567-e89b-12d3-a456-426614174000",
  "SK": "TERMS#1.0",
  "agreedAt": "2025-01-15T14:30:00Z"
}
```

**主要アクセスパターン**:
1. ユーザー別の規約同意履歴取得 - `Query` on PK
2. 特定バージョンへの同意確認 - `GetItem` on PK + SK

**プロビジョニング推奨**:
- 読み取りキャパシティユニット (RCU): オンデマンド（初期段階）
- 書き込みキャパシティユニット (WCU): オンデマンド（初期段階）

**補足**:
- 1ユーザーにつき利用規約バージョン数分のレコードが生成されるシンプルな設計

## 4. DynamoDBインデックス戦略

### 4.1 GSIの活用方針

1. **検索パターン最適化**
   - 頻繁に使用される検索パターンには専用のGSIを作成
   - 例：ユーザーメールによる検索、ステータス別予約取得など

2. **投影属性の最適化**
   - ALL: 完全な情報が必要な場合（Bookingsテーブルのインデックスなど）
   - KEYS_ONLY: 追加情報を取得するための中間クエリに使用
   - INCLUDE: 特定の属性のみが必要な場合

3. **複合キー戦略**
   - パーティションキーとソートキーを効果的に組み合わせることで、きめ細かなクエリを可能に
   - 例：`STATUS#<status>`と`<startTime>`の組み合わせ

### 4.2 LSIの活用方針

本アプリケーションでは、主にGSIを使用し、LSIは現時点では導入していません。LSIはテーブル作成時にのみ定義でき、後から追加できないという制約があるためです。

将来的にLSIが必要になった場合は、新しいテーブル作成と移行が必要になります。

### 4.3 スキャン最小化戦略

スキャンオペレーションは可能な限り避け、以下の戦略を採用します：

1. アクセスパターンの詳細な分析と適切なインデックス設計
2. 複合キー（パーティションキー + ソートキー）を活用した範囲クエリ
3. フィルタ式よりもインデックスを優先
4. 並行スキャンの利用（避けられない場合のみ）

## 5. キャパシティ設計

### 5.1 プロビジョニングモード選択

初期段階ではすべてのテーブルで**オンデマンドモード**を推奨します。理由：

- トラフィックパターンが未確立
- 開発・テスト段階ではトラフィック予測が困難
- コスト効率よりも運用の容易さを優先

### 5.2 段階的最適化

1. **初期段階**: すべてのテーブルでオンデマンドモード
2. **利用パターン確立後**: トラフィック分析に基づきプロビジョニングモードへ移行検討
3. **フルプロビジョニング**: 定期的な使用パターンに合わせた自動スケーリング設定

### 5.3 キャパシティ監視

以下のメトリクスを監視し、キャパシティ調整の判断に使用：

- ConsumedReadCapacityUnits
- ConsumedWriteCapacityUnits
- ProvisionedReadCapacityUnits
- ProvisionedWriteCapacityUnits
- ThrottledRequests

## 6. データ一貫性とトランザクション

### 6.1 トランザクション使用シナリオ

以下のシナリオでは `TransactWriteItems` を使用：

1. **予約作成/更新/キャンセル時**:
   - Bookingsテーブル更新
   - Calendarテーブル更新
   - 同時に行う必要あり

2. **仮予約から本予約への変更時**:
   - 予約ステータス/種類変更
   - キャンセル料率更新
   - 確定期限情報更新

### 6.2 整合性レベルの選択

- **強い整合性読み込み**: 予約状態の確認など、最新状態が重要な場面
- **結果整合性読み込み**: 通知履歴、利用統計など、多少の遅延が許容される場面

## 7. DynamoDBストリーム活用

以下のイベント処理にDynamoDB Streamsを活用：

1. **Bookings テーブル**:
   - 新規予約作成時の管理者通知
   - 予約状態変更時のユーザー通知
   - キャンセル処理後の統計更新

2. **Users テーブル**:
   - 新規ユーザー登録時のウェルカムメール送信
   - プロフィール更新時のセキュリティ通知

3. **Notifications テーブル**:
   - 未読通知数の更新
   - プッシュ通知トリガー（将来拡張）

## 8. スケーリングと最適化

### 8.1 パフォーマンス最適化戦略

1. **インデックス選定**:
   - アクセスパターンごとの最適なインデックス設計
   - 不要なインデックスの排除

2. **項目サイズ最適化**:
   - 属性名の短縮（特に頻出項目）
   - バイナリ型の活用（適切な場合）
   - 大きい項目の分割（必要な場合）

3. **バッチ処理**:
   - BatchGetItem, BatchWriteItem の活用
   - 並行処理の実装

### 8.2 コスト最適化戦略

1. **キャパシティ適正化**:
   - 使用パターンに基づくプロビジョニング
   - 自動スケーリングの設定

2. **データライフサイクル管理**:
   - TTLを使用した古いデータの自動削除
   - 利用頻度の低いデータのアーカイブ（S3へ）

3. **読み取り/書き込みオペレーション最適化**:
   - 不必要なインデックス更新の回避
   - 結果整合性読み込みの活用（適切な場合）
   - 効率的なクエリパターン設計

## 9. バックアップと復元戦略

### 9.1 定期バックアップ

- 毎日の自動バックアップ（AWS Backup）
- 重要なテーブル変更前の手動バックアップ
- バックアップの保持期間: 30日

### 9.2 ポイントインタイム復元 (PITR)

- すべてのテーブルでPITRを有効化
- 復元ウィンドウ: 35日
- テスト環境での定期的な復元テスト

## 10. 監視とアラート

### 10.1 主要メトリクス監視

- **キャパシティ**: ConsumedCapacityUnits, ProvisionedCapacityUnits
- **スロットリング**: ThrottledRequests, ReadThrottleEvents, WriteThrottleEvents
- **レイテンシ**: SuccessfulRequestLatency
- **システムエラー**: SystemErrors, UserErrors

### 10.2 アラート設定

- **スロットリング**: 5分間で5回以上のスロットリング発生時
- **高使用率**: プロビジョニングキャパシティの80%以上を5分間持続使用時
- **エラー率**: 1分間で成功率95%未満時
- **レイテンシ**: 平均レイテンシが200ミリ秒を超過する場合

## 11. 展開戦略

初期MVPのローンチから始め、トラフィックとデータ量の増加に応じて段階的に設計を最適化します：

1. **フェーズ1 (MVP)**: すべてのテーブルでオンデマンドキャパシティ、基本的なインデックス設計
2. **フェーズ2 (最適化)**: 使用パターンに基づく設計調整、追加インデックス、プロビジョニングモードへの切り替え
3. **フェーズ3 (スケール)**: 高可用性設計の強化、グローバルテーブルの検討（将来の地域展開時）

---

このDynamoDBテーブル・インデックス設計はアプリケーションの要件に基づいて作成されており、将来の拡張性も考慮しています。実際のデプロイ前にはプロトタイプ環境での検証が推奨されます。
